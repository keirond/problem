#!/bin/bash

err_echo() {
	echo "$@" >&2
}

usage() {
	err_echo "Usage: run [options] <source_file (without .cpp)> [flags]"
	err_echo ""
	err_echo "Options:"
	err_echo "  -t, --time      Measure and display the runtime."
	err_echo "  -g, --gdb       Debug with GNU Debugger."
	err_echo "  -d, --debug     Enable DEBUG macro."
	err_echo " 	-s, --samples	Run with generated samples (.in) then comparing with expected outputs (.out)."
	err_echo ""
	err_echo "Flags:"
	err_echo "  Any additional flags will be passed directly to g++ compilation."
	err_echo "  Example: run program -lcurl -pthread"
	exit 1
}

compile() {
	local _compile_options="-std=c++20"
	local _warning_flags=("-Wall" "-Wextra")
	local _optimization_flags="-O2"
	# local _debugging_options="-g"
	# local _preprocessor_defines="-DDEBUG"
	# local _include_paths=""
	# local _libraries=""
	local _prefix_flag_count="$3"
	local _prefix_flags=("${@:4:$_prefix_flag_count}")
	local _source_file="$1"
	local _binary_file="$2"
	local _postfix_flags=("${@:4+$_prefix_flag_count}")

	if [[ -z "$_source_file" ]]; then
		err_echo "Error: No source file provided!"
		return 1
	fi

	if [[ ! "$_source_file" =~ ^.+\.cpp$ || ! -f "$_source_file" ]]; then
		err_echo "Error: File '$_source_file' is invalid!"
		return 1
	fi

	if [[ -z "$_binary_file" ]]; then
		err_echo "Error: No executable file provided!"
		return 1
	fi

	check_todo "$_source_file"

	err_echo "Compiling $_source_file with C++20."

	# "$_debugging_options" $_preprocessor_defines "$_include_paths" "$_libraries"
	if g++ "$_compile_options" "${_warning_flags[@]}" "$_optimization_flags" \
		"${_prefix_flags[@]}" "$_source_file" -o "$_binary_file" "${_postfix_flags[@]}"; then
		echo "$_binary_file"
	else
		err_echo "Error: Compilation failed!"
		return 1
	fi
}

check_todo() {
	local _source_file="$1"
	local _todo_lines

	_todo_lines=$(grep "TODO" "$_source_file" 2>/dev/null)
	if [[ -n "$_todo_lines" ]]; then
		err_echo -e "\e[38;5;214mWarning:\e[0m TODOs found in '$_source_file':"
		err_echo "$_todo_lines"
		err_echo ""
	fi
}

run() {
	local _binary_file="$1"
	shift
	local _commands=("$@")

	if [[ -z "$_binary_file" ]]; then
		err_echo "Error: No executable file provided!"
		exit 1
	fi

	err_echo "Running $_binary_file with C++20."

	_commands+=("./$_binary_file")
	eval "${_commands[*]}"
}

commands=()
prefix_flags=()
prefix_count=0

while [[ $# -gt 0 && $1 == -* ]]; do
	case "$1" in
	-t | --time)
		commands+=("time")
		shift
		;;
	-g | --gdb)
		err_echo -e "\e[1m[GDB MODE]\e[0m"
		prefix_flags+=("-g")
		((prefix_count++))
		commands+=("gdb -q")
		shift
		;;
	-d | --debug)
		err_echo -e "\e[1m[DEBUG MODE]\e[0m"
		prefix_flags+=("-DDEBUG")
		((prefix_count++))
		shift
		;;
	*)
		err_echo "Error: Unknown option '$1'!"
		usage
		;;
	esac
done

if [[ $# -lt 1 ]]; then
	usage
fi

source_file="$1.cpp"
output_file="$1"
shift

if ! compiled_file=$(compile "$source_file" "$output_file" "$prefix_count" "${prefix_flags[@]}" "$@"); then
	err_echo "Error: Compilation failed!"
	exit 1
fi

run "$compiled_file" "${commands[@]}"
